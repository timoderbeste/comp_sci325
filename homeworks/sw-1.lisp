(defun camelize-old (str &optional (capitalize nil))
  (do ((i 0 (1+ i))
       (p nil (if (= 0 i) nil (aref str i)))
       (cs nil (let ((c (aref str i)))
		 (cond ((eql #\- c)
			cs)
		       ((eql #\- p)
			(cons (char-upcase c) cs))
		       ((and capitalize (null cs))
			(cons (char-upcase c) cs))
		       (t (cons c cs))))))
      ((= (length str) i)
       (coerce (reverse cs) 'string))))

(defun camelize (str &optional (capitalize nil))
  (let ((fstr (make-array '(0) :element-type 'base-char :fill-pointer 0 :adjustable t)))
    (with-output-to-string (s fstr)
      (do ((i 0 (1+ i))
	   (p nil (if (= 0 i) nil (aref str i)))
	   (start 0 (cond ((and (= start 0) (eql #\- p) (not capitalize))
			   (format s (subseq str start i))
			   i)
			  ((eql #\- p)
			   (format s (string-capitalize (subseq str start i)))
			   i)
			  (t start))))
	  ((= (length str) i)
	   (format s (string-capitalize (subseq str start i)))
	   fstr)))))

(defun hyphenate (str &optional (case :upper))
  (do ((i 0 (1+ i))
       (p nil (if (= 0 i) nil (aref str i)))
       (cs nil (let ((c (aref str i)))
		 (cond ((or (and (null p) (upper-case-p c))
			    (and (not (null p)) (upper-case-p c) (upper-case-p p)))
			(cons c cs))
		       ((upper-case-p c)
			(list* (char-downcase c) #\- cs))
		       (t
			(cons (char-downcase c) cs))))))
      ((= (length str) i)
       (cond ((eql case :upper)
	      (string-upcase (coerce (reverse cs) 'string)))
	     ((eql case :lower)
	      (string-downcase (coerce (reverse cs) 'string)))
	     (t nil)))))
