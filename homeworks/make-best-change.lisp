(defun explore-comb (sum coin-types prev-comb comp)
  (if (null coin-types)
      (list sum (apply #'+ prev-comb) prev-comb)
      (do ((curr-coin-type (car coin-types))
	   (count 0 (1+ count))
	   (curr-comb nil (explore-comb (- sum (* count curr-coin-type))
					(cdr coin-types)
					(cons count prev-comb)
					comp)))
	  ((< (- sum (* count curr-coin-type)) 0) (funcall comp curr-comb) curr-comb)
	(when curr-comb
	  (funcall comp curr-comb)))))

(defun make-best-change (sum &optional (coin-types '(25 10 5 1)))
  (let ((best-comb nil))
    (explore-comb sum coin-types nil (lambda (curr-comb)
				       (when (or (null best-comb)
						 (< (car curr-comb) (car best-comb))
						 (and (= (car curr-comb) (car best-comb))
						      (< (cadr curr-comb) (cadr best-comb))))
					 (setf best-comb curr-comb))))
   ;;; (print best-comb)
    (values-list (reverse (caddr best-comb)))))
